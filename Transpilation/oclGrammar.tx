File:
    (expressions=Expression)*
;
Expression:
      ifExpression=IfExpression
    | letExpression=LetExpression
    | logicalExpression=LogicalExpression
;
LetExpression:
    "let" identifier=Name
    ( "(" extra_identifier=FormalParameterList ")" )?
    ( ":" type=TypeSpecifier )?
    "=" init_expression=Expression "in" expression=Expression
;
IfExpression:
    "if" condition=Expression
    "then" thenBody=Expression
    "else" elseBody=Expression
    "endif"
;
LogicalExpression:
    leftRelationalExpression=RelationalExpression
    ( logicalOperator=LogicalOperator
    rightRelationalExpression=RelationalExpression
    )*
;
RelationalExpression:
    leftAdditiveExpression=AdditiveExpression
    ( relationalOperator=RelationalOperator
    rightAdditiveExpression=AdditiveExpression
    )?
;
AdditiveExpression:
    leftMultiplicativeExpression=MultiplicativeExpression
    ( addOperator=AddOperator
    rightMultiplicativeExpression=MultiplicativeExpression
    )*
;
MultiplicativeExpression:
    leftUnaryExpression=UnaryExpression
    ( multiplyOperator=MultiplyOperator
    rightUnaryExpression=UnaryExpression
    )*
;
UnaryExpression:
    ( unaryOperator=UnaryOperator) ? postfixExpression=PostfixExpression
;
PostfixExpression:
    primaryExpression=PrimaryExpression
    ( ( "." | "->" ) propertyCall=PropertyCall )*
;
PrimaryExpression:
    literalCollection=LiteralCollection
    | literal=Literal
    | propertyCall=PropertyCall
    | "(" epression=Expression ")"
    | ifExpression=IfExpression
;
UnaryOperator:
    "-" | "not"
;
LiteralCollection:
    collectionKind=CollectionKind "{"
    ( collectionItems=CollectionItem
        ("," collectionItems=CollectionItem )*
    )?
    "}"
;
CollectionKind:
    "Set" | "Bag" | "Sequence" | "Collection"
;
CollectionItem:
    startExpression=Expression (".." endExpression=Expression )?
;
PropertyCall:
    pathName=PathName
    ( timeExpression=TimeExpression )?
    ( qualifiers=Qualifiers )?
    ( propertyCallParameters=PropertyCallParameters )?
;
Qualifiers:
    "[" actualParameterList=ActualParameterList "]"
;
PathName:
    names=Name ( "::" names=Name )*
;
TimeExpression:
    "@" "pre"
;
ActualParameterList:
    expressions=Expression ( "," expressions=Expression )*
;
Literal:
    string=String
    | number=Number
    | enumLiteral=EnumLiteral
;
EnumLiteral:
    names=Name "::" names=Name ( "::" names=Name )*
;
Name:
    /[a-zA-Z_]([a-zA-Z0-9_])*/
;
Number:
    NUMBER
;
String:
    STRING
;
PropertyCallParameters:
    "(" ( declarator=Declarator )?
    ( actualParameterList=ActualParameterList )? ")"
;
Declarator:
    names=Name ( "," names=Name )*
    ( ":" simpleTypeSpecifier=SimpleTypeSpecifier )?
    ( ";" extraNames=Name ":" extraTypeSpecifier=TypeSpecifier "="
        expression=Expression
    )?
    "|"
;
SimpleTypeSpecifier:
    pathName=PathName
;
TypeSpecifier:
    simpleTypeSpecifier=SimpleTypeSpecifier | collectionType=CollectionType
;
CollectionType:
    collectionKind=CollectionKind
    "(" simpleTypeSpecifier=SimpleTypeSpecifier ")"
;
LogicalOperator:
    "and" | "or" | "xor" | "implies"
;
CollectionKind:
    "Set" | "Bag" | "Sequence" | "Collection"
;
RelationalOperator:
    "=" | ">" | "<" | ">=" | "<=" | "<>"
;
AddOperator:
    "+" |  "-"
;
MultiplyOperator:
    "*" | "/"
;
UnaryOperator:
    "-" | "not"
;
FormalParameterList:
    ( names=Name ":" typeSpecifiers=TypeSpecifier
    ("," names=Name ":" typeSpecifiers=TypeSpecifier )*
    )?
;
