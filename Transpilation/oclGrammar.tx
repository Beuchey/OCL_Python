File:
    (expressions=Expression)*
;
Expression:
      ifExpression=IfExpression
    | letExpression=LetExpression
    | logicalExpression=LogicalExpression
;
LetExpression:
    "let" identifier=Name
    ( "(" extra_identifiers=FormalParameterList ")" )?
    ( ":" type=TypeSpecifier )?
    "=" init_expression=Expression "in" expression=Expression
;
IfExpression:
    "if" condition=Expression
    "then" then_body=Expression
    "else" else_body=Expression
    "endif"
;
LogicalExpression:
    left=RelationalExpression
    ( operator=LogicalOperator
    right=RelationalExpression
    )*
;
RelationalExpression:
    left=AdditiveExpression
    ( operator=RelationalOperator
    right=AdditiveExpression
    )?
;
AdditiveExpression:
    left=MultiplicativeExpression
    ( operator=AddOperator
    right=MultiplicativeExpression
    )*
;
MultiplicativeExpression:
    left=UnaryExpression
    ( operator=MultiplyOperator
    right=UnaryExpression
    )*
;
UnaryExpression:
    ( operator=UnaryOperator) ? left=PostfixExpression
;
PostfixExpression:
    expression=PrimaryExpression
    ( ( "." | "->" ) call=PropertyCall )*
;
PrimaryExpression:
    literalCollection=LiteralCollection
    | literal=Literal
    | propertyCall=PropertyCall
    | "(" epression=Expression ")"
    | ifExpression=IfExpression
;
UnaryOperator:
    "-" | "not"
;
LiteralCollection:
    kind=CollectionKind "{"
    ( items=CollectionItem
        ("," items=CollectionItem )*
    )?
    "}"
;
CollectionKind:
    "Set" | "Bag" | "Sequence" | "Collection"
;
CollectionItem:
    start=Expression (".." end=Expression )?
;
PropertyCall:
    property=PathName
    ( time_expression=TimeExpression )?
    ( qualifiers=Qualifiers )?
    ( parameters=PropertyCallParameters )?
;
Qualifiers:
    "[" actualParameterList=ActualParameterList "]"
;
PathName:
    path=Name ( "::" path=Name )*
;
TimeExpression:
    "@" "pre"
;
ActualParameterList:
    params=Expression ( "," params=Expression )*
;
Literal:
    string=String
    | number=Number
    | enumLiteral=EnumLiteral
;
EnumLiteral:
    paths=Name "::" paths=Name ( "::" paths=Name )*
;
Name:
    /[a-zA-Z_]([a-zA-Z0-9_])*/
;
Number:
    NUMBER
;
String:
    STRING
;
PropertyCallParameters:
    "(" ( declarator=Declarator )?
    ( actualParameterList=ActualParameterList )? ")"
;
Declarator:
    id=Name ( "," extra_ids=Name )*
    ( ":" simpleTypeSpecifier=SimpleTypeSpecifier )?
    ( ";" name=Name ":" typeSpecifier=TypeSpecifier "="
        expression=Expression
    )?
    "|"
;
SimpleTypeSpecifier:
    pathName=PathName
;
TypeSpecifier:
    simpleTypeSpecifier=SimpleTypeSpecifier | collectionType=CollectionType
;
CollectionType:
    kind=CollectionKind
    "(" type=SimpleTypeSpecifier ")"
;
LogicalOperator:
    "and" | "or" | "xor" | "implies"
;
CollectionKind:
    "Set" | "Bag" | "Sequence" | "Collection"
;
RelationalOperator:
    "=" | ">" | "<" | ">=" | "<=" | "<>"
;
AddOperator:
    "+" |  "-"
;
MultiplyOperator:
    "*" | "/"
;
UnaryOperator:
    "-" | "not"
;
FormalParameterList:
    ( names=Name ":" typeSpecifiers=TypeSpecifier
    ("," names=Name ":" typeSpecifiers=TypeSpecifier )*
    )?
;
